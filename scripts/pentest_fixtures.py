import hashlib
import json
import os
import random
import subprocess
import tarfile
import time
from contextlib import contextmanager
from io import BytesIO
from pathlib import Path
from tempfile import NamedTemporaryFile, TemporaryDirectory

import numpy
import SimpleITK
from allauth.account.models import EmailAddress
from allauth.mfa import recovery_codes, totp
from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.files.base import ContentFile
from django.core.files.uploadedfile import InMemoryUploadedFile
from django.utils.crypto import get_random_string
from django.utils.timezone import now
from faker import Faker
from knox.models import AuthToken
from PIL import Image as PILImage
from PIL import ImageDraw, ImageFont

from grandchallenge.algorithms.models import (
    Algorithm,
    AlgorithmImage,
    AlgorithmInterface,
    Job,
)
from grandchallenge.archives.models import Archive, ArchiveItem
from grandchallenge.cases.models import Image, ImageFile
from grandchallenge.challenges.models import Challenge
from grandchallenge.components.models import (
    ComponentInterface,
    ComponentInterfaceValue,
)
from grandchallenge.direct_messages.models import Conversation, DirectMessage
from grandchallenge.evaluation.models import (
    Evaluation,
    Method,
    Phase,
    Submission,
)
from grandchallenge.evaluation.utils import SubmissionKindChoices
from grandchallenge.invoices.models import Invoice
from grandchallenge.pages.models import Page
from grandchallenge.reader_studies.models import (
    Answer,
    DisplaySet,
    Question,
    QuestionWidgetKindChoices,
    ReaderStudy,
)
from grandchallenge.verifications.models import Verification
from grandchallenge.workstations.models import Workstation, WorkstationImage

NUM_ARCHIVE_ITEMS = 3


def run():
    with _demo_container() as container:
        create_superuser()
        create_challenges(container=container)
        create_archives()
        create_reader_studies()
        create_algorithms(container=container)
        create_workstations(container=container)


def create_challenges(*, container):
    challenge_count = Challenge.objects.count()

    for ii, public in enumerate([True, True, False, False]):
        create_challenge(
            challenge_num=challenge_count + 1 + ii,
            container=container,
            public=public,
        )


def create_archives():
    archive_count = Archive.objects.count()

    for ii, public in enumerate([True, True, False, False]):
        create_archive(archive_num=archive_count + 1 + ii, public=public)


def create_reader_studies():
    reader_study_count = ReaderStudy.objects.count()

    for ii, public in enumerate([True, True, False, False]):
        create_reader_study(
            reader_study_num=reader_study_count + 1 + ii, public=public
        )


def create_workstations(*, container):
    workstation_count = Workstation.objects.count()

    for ii, public in enumerate([True, True, False, False]):
        create_workstation(
            workstation_num=workstation_count + 1 + ii,
            container=container,
            public=public,
        )


def create_algorithms(*, container):
    algorithm_count = Algorithm.objects.count()

    for ii, public in enumerate([True, True, False, False]):
        create_algorithm(
            algorithm_num=algorithm_count + 1 + ii,
            container=container,
            create_jobs=True,
            public=public,
        )


def create_challenge(*, challenge_num, container, public):
    admin = _create_user(f"challenge-{challenge_num}", "admin")
    participant_1 = _create_user(f"challenge-{challenge_num}", "participant-1")
    participant_2 = _create_user(f"challenge-{challenge_num}", "participant-2")

    create_direct_messages([(admin, participant_1), (admin, participant_2)])

    challenge_title = f"Challenge {challenge_num}"

    if public:
        challenge_title += " (Public),"
    else:
        challenge_title += " (Non-Public),"

    c = Challenge.objects.create(
        short_name=f"challenge-{challenge_num}",
        creator=admin,
        hidden=not public,
        logo=create_image_with_text(text=f"{challenge_title}, Logo"),
    )

    c.add_participant(participant_1)
    c.add_participant(participant_2)

    Page.objects.create(
        challenge=c,
        display_title="For All",
        permission_level="ALL",
        content_markdown="This page should be visible by all",
    )
    Page.objects.create(
        challenge=c,
        display_title="For Participants",
        permission_level="REG",
        content_markdown="This page should only be visible by this challenges participants",
    )
    Page.objects.create(
        challenge=c,
        display_title="For Admins",
        permission_level="ADM",
        content_markdown="This page should only be visible by this challenges admins",
    )

    Invoice.objects.create(
        challenge=c,
        support_costs_euros=0,
        compute_costs_euros=10,
        storage_costs_euros=0,
        payment_status=Invoice.PaymentStatusChoices.PAID,
        billing_address="Geert Grooteplein Zuid 10, 6525 GA Nijmegen",
        contact_email="invoices@example.org",
        contact_name="Jane Doe",
        paid_on=now(),
        vat_number="NL12345678",
    )

    participant_1_algorithm = create_algorithm(
        container=container,
        title=f"{challenge_title}, Participant 1, Algorithm",
        editor=participant_1,
    )
    participant_2_algorithm = create_algorithm(
        container=container,
        title=f"{challenge_title}, Participant 2, Algorithm",
        editor=participant_2,
    )

    for ii, give_algorithm_editors_job_view_permissions in enumerate(
        (True, False)
    ):
        phase_num = ii + 1

        phase_title = f"{challenge_title}, Phase {phase_num}"

        archive = _create_phase_archive(
            creator=admin,
            interfaces=_get_inputs(),
            title=f"{phase_title}, Test Set",
        )

        p = Phase.objects.create(
            challenge=c,
            title=phase_title,
            algorithm_time_limit=300,
            submission_kind=SubmissionKindChoices.ALGORITHM,
            archive=archive,
            score_jsonpath="score",
            submissions_limit_per_user_per_period=10,
            give_algorithm_editors_job_view_permissions=give_algorithm_editors_job_view_permissions,
        )

        interface = AlgorithmInterface.objects.create(
            inputs=_get_inputs(), outputs=_get_outputs()
        )
        p.algorithm_interfaces.set([interface])

        m = Method(creator=admin, phase=p)

        with open(container, "rb") as f:
            m.image.save("method_io.tar", ContentFile(f.read()))

        await_method_and_image_validation()

        Submission.objects.create(
            creator=participant_1,
            phase=p,
            algorithm_image=participant_1_algorithm.active_image,
            comment=f"{phase_title}, Participant 1, Submission",
        )
        Submission.objects.create(
            creator=participant_2,
            phase=p,
            algorithm_image=participant_2_algorithm.active_image,
            comment=f"{phase_title}, Participant 2, Submission",
        )


def await_method_and_image_validation():
    print(
        ">>> Waiting for all AlgorithmImages, Methods, Jobs and Evaluations to complete..."
    )

    while True:
        if (
            AlgorithmImage.objects.exclude(
                import_status=AlgorithmImage.ImportStatusChoices.COMPLETED
            ).exists()
            or Method.objects.exclude(
                import_status=Method.ImportStatusChoices.COMPLETED
            ).exists()
            or Job.objects.exclude(status=Job.SUCCESS).exists()
            or Evaluation.objects.exclude(status=Evaluation.SUCCESS).exists()
        ):
            time.sleep(1)
        else:
            break


def _get_inputs():
    return ComponentInterface.objects.filter(
        slug__in=["generic-medical-image"]
    )


def _get_outputs():
    return ComponentInterface.objects.filter(
        slug__in=["generic-medical-image", "results-json-file"]
    )


def create_archive(*, archive_num, public):
    editor = _create_user(f"archive-{archive_num}", "editor")
    uploader = _create_user(f"archive-{archive_num}", "uploader")
    user = _create_user(f"archive-{archive_num}", "user")

    title = f"Archive {archive_num}"

    if public:
        title += " (Public),"
    else:
        title += " (Non-Public),"

    archive = Archive.objects.create(
        title=title,
        public=public,
        logo=create_image_with_text(text=f"{title}, Logo"),
        workstation=Workstation.objects.get(
            slug=settings.DEFAULT_WORKSTATION_SLUG
        ),
    )

    archive.add_editor(editor)
    archive.add_uploader(uploader)
    archive.add_user(user)

    add_archive_item(archive=archive, interfaces=_get_inputs())


def _create_phase_archive(*, creator, interfaces, title):
    archive = Archive.objects.create(
        title=title,
        logo=create_image_with_text(text=f"{title}, Logo"),
        workstation=Workstation.objects.get(
            slug=settings.DEFAULT_WORKSTATION_SLUG
        ),
    )
    archive.add_editor(creator)

    for _ in range(NUM_ARCHIVE_ITEMS):
        add_archive_item(archive=archive, interfaces=interfaces)

    return archive


def add_archive_item(*, archive, interfaces):
    archive_item_num = ArchiveItem.objects.filter(archive=archive).count() + 1
    ai = ArchiveItem.objects.create(archive=archive)

    for interface in interfaces:
        ai.values.add(
            _create_civ(
                interface=interface,
                name=f"{archive.title}, Image {archive_item_num}, {interface.title}",
            )
        )


def _create_civ(*, interface, name):
    civ = ComponentInterfaceValue.objects.create(interface=interface)

    im = Image.objects.create(name=name, width=10, height=10)
    im_file = ImageFile.objects.create(image=im)

    with _uploaded_image_file(text=name) as f:
        im_file.file.save(f"{im_file.pk}.mha", f)
        im_file.save()

    civ.image = im
    civ.save()

    return civ


def create_reader_study(*, reader_study_num, public):
    editor = _create_user(f"reader-study-{reader_study_num}", "editor")
    reader_1 = _create_user(f"reader-study-{reader_study_num}", "reader-1")
    reader_2 = _create_user(f"reader-study-{reader_study_num}", "reader-2")

    create_direct_messages([(editor, reader_1), (editor, reader_2)])

    title = f"Reader Study {reader_study_num}"

    if public:
        title += " (Public),"
    else:
        title += " (Non-Public),"

    interface = ComponentInterface.objects.get(slug="generic-medical-image")

    reader_study = ReaderStudy.objects.create(
        title=title,
        public=public,
        workstation=Workstation.objects.last(),
        logo=create_image_with_text(text=f"{title}, Logo"),
        view_content={"main": [interface.slug]},
    )

    reader_study.add_editor(editor)
    reader_study.add_reader(reader_1)
    reader_study.add_reader(reader_2)

    question = Question.objects.create(
        reader_study=reader_study,
        question_text=f"{title} question",
        answer_type=Question.AnswerType.TEXT,
        widget=QuestionWidgetKindChoices.TEXT_INPUT,
    )

    display_set = DisplaySet.objects.create(
        reader_study=reader_study,
    )

    display_set.values.add(
        _create_civ(
            interface=interface,
            name=f"{reader_study.title}, Image 1, {interface.title}",
        )
    )

    Answer.objects.create(
        creator=reader_1,
        question=question,
        answer="Reader 1 answer",
        display_set=display_set,
    )

    Answer.objects.create(
        creator=reader_2,
        question=question,
        answer="Reader 2 answer",
        display_set=display_set,
    )


def create_algorithm(
    *,
    container,
    algorithm_num=None,
    title=None,
    editor=None,
    create_jobs=False,
    public=False,
):
    assert algorithm_num is not None or (
        title is not None and editor is not None
    )

    if create_jobs:
        assert editor is None

    if title is None:
        title = f"Algorithm {algorithm_num}"

    inputs = _get_inputs()
    outputs = _get_outputs()

    if public:
        title += " (Public)"
    else:
        title += " (Non-Public)"

    algorithm = Algorithm.objects.create(
        title=title,
        logo=create_image_with_text(text=f"{title}, Logo"),
        public=public,
    )

    interface = AlgorithmInterface.objects.create(
        inputs=inputs, outputs=outputs
    )
    algorithm.interfaces.set([interface])

    if editor is None:
        editor = _create_user(f"algorithm-{algorithm_num}", "editor")
        user = _create_user(f"algorithm-{algorithm_num}", "user")

        algorithm.add_user(user)

    algorithm.add_editor(editor)

    algorithm_image = AlgorithmImage(creator=editor, algorithm=algorithm)

    with add_env_var_to_container(
        tarball_path=container, new_env_var=f"TITLE={title!r}"
    ) as f:
        algorithm_image.image.save("algorithm_io.tar", ContentFile(f.read()))

    if create_jobs:
        await_method_and_image_validation()

        interface = ComponentInterface.objects.get(
            slug="generic-medical-image"
        )

        shared_job_idx = 2

        for ii, public in enumerate((True, False, False)):
            job_num = ii + 1

            job_title = f"{title}, Job {job_num}"

            if public:
                job_title += ", Public"
            elif job_num == shared_job_idx:
                job_title += ", Shared"

            job = Job.objects.create(
                algorithm_image=algorithm_image,
                algorithm_interface=interface,
                creator=user,
                public=public,
                comment=job_title,
                input_civ_set=[
                    _create_civ(
                        interface=interface,
                        name=f"{job_title}, Input {interface.title}",
                    )
                ],
                time_limit=algorithm_image.algorithm.time_limit,
                requires_gpu_type=algorithm_image.algorithm.job_requires_gpu_type,
                requires_memory_gb=algorithm_image.algorithm.job_requires_memory_gb,
            )

            job.execute()

            if not public and job_num == shared_job_idx:
                viewer = _create_user(
                    f"algorithm-{algorithm_num}-job-{job_num}", "viewer"
                )
                job.add_viewer(viewer)

    return algorithm


def create_workstation(*, workstation_num, container, public):
    editor = _create_user(f"workstation-{workstation_num}", "editor")
    user = _create_user(f"workstation-{workstation_num}", "user")

    title = f"Workstation {workstation_num}"

    if public:
        title += " (Public),"
    else:
        title += " (Non-Public),"

    workstation = Workstation.objects.create(
        title=title,
        public=public,
        logo=create_image_with_text(text=f"{title}, Logo"),
    )

    workstation.add_editor(editor)
    workstation.add_user(user)

    workstation_image = WorkstationImage(
        creator=editor, workstation=workstation
    )

    with open(container, "rb") as f:
        workstation_image.image.save("workstation.tar", ContentFile(f.read()))


@contextmanager
def _uploaded_image_file(*, text):
    jpeg_bytes = create_image_with_text(text=text)
    pil_image = PILImage.open(jpeg_bytes).convert("L")
    numpy_image = numpy.array(pil_image)
    sitk_image = SimpleITK.GetImageFromArray(numpy_image)

    with NamedTemporaryFile(suffix=".mha") as f:
        writer = SimpleITK.ImageFileWriter()
        writer.SetFileName(f.name)
        writer.SetImageIO("MetaImageIO")
        writer.Execute(sitk_image)

        f.seek(0)

        with ContentFile(f.read()) as content:
            yield content


@contextmanager
def _demo_container():
    with TemporaryDirectory() as tmp_dir:
        tmp_path = Path(tmp_dir)

        repo_tag = "grandchallenge/demo-algorithm-and-method:latest"

        outfile = tmp_path / "container.tar"

        try:
            subprocess.run(
                [
                    "crane",
                    "pull",
                    repo_tag,
                    str(outfile.absolute()),
                    "--platform",
                    settings.COMPONENTS_CONTAINER_PLATFORM,
                ],
                check=True,
                capture_output=True,
                text=True,
            )
        except subprocess.CalledProcessError as e:
            print(e.stderr)
            raise

        yield outfile


def create_image_with_text(
    *,
    text,
    image_size=(1024, 1024),
    font_size=50,
    font_path="Roboto-Regular.ttf",
):
    # Create a new image with a black background
    image = PILImage.new("RGB", image_size, color="black")

    # Initialize the drawing context
    draw = ImageDraw.Draw(image)

    # Load the specified font
    try:
        font = ImageFont.truetype(font_path, font_size)
    except OSError:
        print(f"Font file {font_path} not found. Using default font.")
        font = ImageFont.load_default()

    # Calculate the bounding box of the text to be added
    text = text.replace(", ", "\n")
    text_bbox = draw.textbbox((0, 0), text, font=font)
    text_width = text_bbox[2] - text_bbox[0]
    text_height = text_bbox[3] - text_bbox[1]

    # Calculate X, Y position of the text to be centered
    x = (image_size[0] - text_width) / 2
    y = (image_size[1] - text_height) / 2

    # Add text to image
    draw.text((x, y), text, font=font, fill=(255, 255, 255))

    # Save the image
    io = BytesIO()
    image.save(io, format="JPEG")
    image_file = InMemoryUploadedFile(
        io, None, f"{text}.jpg", "jpeg", image.size, None
    )
    image_file.seek(0)

    return image_file


def _create_user(first_name, last_name, *, superuser=False):
    fake = Faker()

    user = get_user_model().objects.create(
        username=f"{first_name}-{last_name}",
        email=f"{first_name}-{last_name}@example.com",
        is_active=True,
        first_name=first_name,
        last_name=last_name,
    )

    users_password = get_random_string(32)

    user.set_password(users_password)
    user.save()

    EmailAddress.objects.create(
        user=user,
        email=user.email,
        verified=True,
        primary=True,
    )

    Verification.objects.create(
        user=user,
        email=user.email,
        is_verified=True,
    )

    user.user_profile.institution = fake.company()
    user.user_profile.department = f"Department of {fake.job().title()}s"
    user.user_profile.country = fake.country_code()
    user.user_profile.receive_newsletter = True
    user.user_profile.save()

    _, token = AuthToken.objects.create(user=user, expiry=None)

    user_info = {
        "username": user.username,
        "password": users_password,
        "api-token": token,
    }

    if superuser:
        user.is_staff = True
        user.is_superuser = True
        user.save()

        totp.TOTP.activate(user, totp.generate_totp_secret())
        recovery_code_device = recovery_codes.RecoveryCodes.activate(user)
        codes = recovery_code_device.generate_codes()

        user_info["recovery_codes"] = codes

    print(json.dumps(user_info), end=",\n")

    return user


def create_superuser():
    if not get_user_model().objects.filter(is_superuser=True).exists():
        _create_user("super", "user", superuser=True)


def create_direct_messages(users):
    fake = Faker()

    for combination in users:
        conversation = Conversation.objects.create()
        conversation.participants.set(combination)

        unread = random.choice([True, False])

        for _ in range(5):
            sender = random.choice(combination)
            message = DirectMessage.objects.create(
                conversation=conversation,
                sender=sender,
                message=fake.text(max_nb_chars=160),
            )
            if unread:
                message.unread_by.set({*combination} - {sender})


def extract_tarball(tarball_path, extract_path):
    with tarfile.open(tarball_path, "r") as tar:
        tar.extractall(path=extract_path)


def calculate_sha256(file_path):
    sha256 = hashlib.sha256()
    with open(file_path, "rb") as file:
        while chunk := file.read(8192):
            sha256.update(chunk)
    return sha256.hexdigest()


def modify_config_json(config_json_path, new_env_var):
    with open(config_json_path) as file:
        config = json.load(file)

    env_var_key, env_var_value = new_env_var.split("=", 1)
    new_env_entry = f"{env_var_key}={env_var_value}"

    if "Env" in config["config"]:
        config["config"]["Env"].append(new_env_entry)
    else:
        config["config"]["Env"] = [new_env_entry]

    with open(config_json_path, "w") as file:
        json.dump(config, file)

    return config


def update_manifest(manifest_path, config_digest, config_size):
    with open(manifest_path) as file:
        manifest = json.load(file)

    manifest[0]["Config"] = f"{config_digest}.json"
    manifest[0]["ConfigSize"] = config_size

    with open(manifest_path, "w") as file:
        json.dump(manifest, file)


def rename_file_with_digest(original_path, new_digest):
    new_path = os.path.join(
        os.path.dirname(original_path), f"{new_digest}.json"
    )
    os.rename(original_path, new_path)
    return new_path


def create_tarball(source_dir, tarball_path):
    with tarfile.open(tarball_path.name, "w") as tar:
        for root, _, files in os.walk(source_dir):
            for file in files:
                fullpath = os.path.join(root, file)
                arcname = os.path.relpath(fullpath, start=source_dir)
                tar.add(fullpath, arcname=arcname)


@contextmanager
def add_env_var_to_container(tarball_path, new_env_var):
    with TemporaryDirectory() as work_dir:
        extract_tarball(tarball_path, work_dir)

        manifest_path = os.path.join(work_dir, "manifest.json")
        with open(manifest_path) as file:
            manifest = json.load(file)

        config_json_path = os.path.join(work_dir, manifest[0]["Config"])
        modify_config_json(config_json_path, new_env_var)

        config_digest = calculate_sha256(config_json_path)
        config_size = os.path.getsize(config_json_path)

        rename_file_with_digest(config_json_path, config_digest)
        update_manifest(manifest_path, config_digest, config_size)

        with NamedTemporaryFile() as new_tarball_path:
            create_tarball(work_dir, new_tarball_path)

            yield new_tarball_path
